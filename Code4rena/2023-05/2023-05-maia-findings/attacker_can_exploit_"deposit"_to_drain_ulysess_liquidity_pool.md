## Tags

- bug
- 3 (High Risk)
- judge review requested
- primary issue
- satisfactory
- selected for report
- sponsor confirmed
- H-19

# [Attacker can exploit "deposit" to drain Ulysess Liquidity Pool](https://github.com/code-423n4/2023-05-maia-findings/issues/435) 

# Lines of code

https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L942-L1019


# Vulnerability details

## Impact
Users have two methods to add liquidity to the Ulysses Pool: "mint" and "deposit". However, the latter may return an inaccurate output, which could be exploited to drain the pool.

## Proof of Concept
In the process to mint `amount` of share, the state change is `A:(band, supply×weight) -> B:(band+update, (supply+amount)×weight)`. User pays `amount-sum(posFee)+sum(negFee)` of underlying to acquire `amount` of share. This approach is precise.

In the process to deposit `amount` of underlying, the simulated state change is `A:(band, supply×weight) -> B:(band+update, (supply+amount)×weight)`. Then `(posFee, negFee)` is derived from the simulation of `A->B`. The actual state change is `A:(band, supply×weight) -> B':(band+update+posFee, (supply+amount+sum(posFee)-sum(negFee))×weight)`. We denote the actual fee of `A->B'` as `(posFee', negFee')`. User pays `amount` of underlying to acquire `amount+sum(posFee)-sum(negFee)` of share. This approach would be acceptable if `sum(pos')-sum(neg') >= sum(pos)`, but this inequality doesn't always hold. If `sum(pos')-sum(neg') < sum(pos)`, insolvency occurs; if `sum(pos')-sum(neg') < sum(pos)-sum(neg)`, user could take profit.

An example is given below:
```
amount = 10000000
supply = 1000000000000000013287555072
weight = [1, 59, 47]
band = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517]
```
When Alice deposits `10000000` underlying, she will get `36215776` share. However, the pool actually worsens.
```
oldRebalancingFee = [0, 10519971631761767037843097, 18152377668510835770992]
newRebalancingFee = [0, 10519971631761767000804564, 18152377668510882599904]
oldMinusNew = [0, +37038533, -46828912]
```
Actually there should be a systemic approach to construct states of `sum(pos')-sum(neg') < sum(pos)-sum(neg)` for attacks. However, due to limited time, I have only conducted random tests. By continuously searching for profitable states and modifying the pool state accordingly, attackers can eventually drain the pool.

## FAQ
Here are several questions that readers may have:

Q: Why there are three diffrent scenarios? Why could insolvency and user loss happen simultaneously?
A: Imagine when you deposit 100\$ to a bank, the bank increases your balance by 80\$ and claims itself has got 120\$.

Q: Why can `sum(pos')-sum(neg') >= sum(pos)` not hold?
A: Difficult question! Roughly this could happen when amount is significantly smaller than supply and posFee is excessively large.

Q: How can the pool be modified to a target state?
A: There are several methods including "mint", "redeem" and "swap", but the "deposit" method should not be used until we reach the target state because attacker will mostly experience losses from that.

Q: Why can the attacker eventually drain the pool?
A：When "mint", "redeem" or "swap", the attacker pays exactly the delta value of `_calculateRebalancingFee`. However, when making a "deposit", the attacker receives more than what they deserve. At last, by adding liquidity, `_calculateRebalancingFee` can be reduced, so the pool will be drained.

Q: Why don't you provide a coded POC of attack?
A: We know "deposit" is dangerous and we deprecate it, that's enough.

## Tools Used
Python
```
# -*- coding: utf-8 -*-
"""
Created on Mon Jun 19 10:24:56 2023

@author: xuwinnie
"""

from random import *

def getBandwidthUpdateAmounts(roundUp, positiveTransfer, amount, _totalWeights, _totalSupply):
    # Get the bandwidth state list length
    global length, weightArray, bandwithArray

    # Initialize bandwidth update amounts
    bandwidthUpdateAmounts = [0] * length
    # Initialize bandwidth differences from target bandwidth
    diffs = [0] * length

    # Total difference from target bandwidth of all bandwidth states
    totalDiff = 0
    # Total difference from target bandwidth of all bandwidth states
    transfered = 0
    # Total amount to be distributed according to each bandwidth weights
    transferedChange = 0

    for i in range(length):
        # Load bandwidth and weight from storage
        # Bandwidth is the first 248 bits of the slot
        bandwidth = bandwithArray[i]
        # Weight is the last 8 bits of the slot
        weight = weightArray[i]

        # Calculate the target bandwidth
        targetBandwidth = (_totalSupply * weight) // _totalWeights

        # Calculate the difference from the target bandwidth
        if positiveTransfer:
            # If the transfer is positive, calculate deficit from target bandwidth
            if targetBandwidth > bandwidth:
                # Calculate the difference
                diff = targetBandwidth - bandwidth
                # Add the difference to the total difference
                totalDiff += diff
                # Store the difference in the diffs array
                diffs[i] = diff
        else:
            # If the transfer is negative, calculate surplus from target bandwidth
            if bandwidth > targetBandwidth:
                # Calculate the difference
                diff = bandwidth - targetBandwidth
                # Add the difference to the total difference
                totalDiff += diff
                # Store the difference in the diffs array
                diffs[i] = diff

    # Calculate the amount to be distributed according deficit/surplus
    # and/or the amount to be distributed according to each bandwidth weights
    if amount > totalDiff:
        # If the amount is greater than the total deficit/surplus
        # Total deficit/surplus is distributed
        transfered = totalDiff
        # Set rest to be distributed according to each bandwidth weights
        transferedChange = amount - totalDiff
    else:
        # If the amount is less than the total deficit/surplus
        # Amount will be distributed according to deficit/surplus
        transfered = amount

    for i in range(length):
        # Increase/decrease amount of bandwidth for each bandwidth state
        bandwidthUpdate = 0

        # If there is a deficit/surplus, calculate the amount to be distributed
        if transfered > 0:
            # Load the difference from the diffs array
            diff = diffs[i]

            # Calculate the amount to be distributed according to deficit/surplus
            if roundUp:
                bandwidthUpdate = (transfered * diff + totalDiff - 1) // totalDiff
            else:
                bandwidthUpdate = (transfered * diff) // totalDiff
        # If there is a rest, calculate the amount to be distributed according to each bandwidth weights
        if transferedChange > 0:
            # Load weight from storage
            weight = weightArray[i]

            # Calculate the amount to be distributed according to each bandwidth weights
            if roundUp:
                bandwidthUpdate += (transferedChange * weight + _totalWeights - 1) // _totalWeights
            else:
                bandwidthUpdate += (transferedChange * weight) // _totalWeights

        # If there is an update in bandwidth
        if bandwidthUpdate > 0:
            # Store the amount to be updated in the bandwidthUpdateAmounts array
            bandwidthUpdateAmounts[i] = bandwidthUpdate

    return (bandwidthUpdateAmounts, length)

def updateBandwidth(depositFees, positiveTransfer, destinationState, difference, _totalWeights, _totalSupply, _newTotalSupply):
    global weightArray, bandwithArray
    
    print("  updating "+str(destinationState)+" with diffrence "+str(difference))
    bandwidth = bandwithArray[destinationState]
    print("    old bandwith "+str(bandwidth))
    weight = weightArray[destinationState]

    # Get the target bandwidth
    targetBandwidth = (_totalSupply * weight) // _totalWeights

    # Get the rebalancing fee prior to updating the bandwidth
    oldRebalancingFee = calculateRebalancingFee(bandwidth, targetBandwidth, positiveTransfer)

    if positiveTransfer:
        # If the transfer is positive
        # Add the difference to the bandwidth
        bandwidth += difference

    else:
        # If the transfer is negative
        # Subtract the difference from the bandwidth
        bandwidth -= difference

    if _newTotalSupply > 0:
        # True on deposit, mint and redeem
        # Get the new target bandwidth after total supply change
        targetBandwidth = (_newTotalSupply * weight) // _totalWeights

    # Get the rebalancing fee after updating the bandwidth
    newRebalancingFee = calculateRebalancingFee(bandwidth, targetBandwidth, positiveTransfer)

    positiveFee, negativeFee = 0, 0
    if newRebalancingFee < oldRebalancingFee:
        # If new fee is lower than old fee
        # Calculate the positive fee
        positiveFee = oldRebalancingFee - newRebalancingFee
        print("    positiveFee "+str(positiveFee))

        if depositFees:
            # If depositFees is true, add the positive fee to the bandwidth
            bandwidth += positiveFee

    else:
        # If new fee is higher than old fee
        if newRebalancingFee > oldRebalancingFee:
            # Calculate the negative fee
            negativeFee = newRebalancingFee - oldRebalancingFee
            print("    negativeFee "+str(negativeFee))
            #raise Exception("good")
        else: print("    no fee")

    # Update storage with the new bandwidth
    bandwithArray[destinationState] = bandwidth
    print("    new bandwith "+str(bandwidth))

    return (positiveFee, negativeFee)

def calculateRebalancingFee(bandwidth, targetBandwidth, roundDown):
    # If the bandwidth is larger or equal to the target bandwidth, return 0
    if bandwidth >= targetBandwidth:
        return 0

    # Fee tier 1 (fee % divided by 2)
    lambda1 = int(20e14)
    # Fee tier 2 (fee % divided by 2)
    lambda2 = int(4980e14)
    # Get sigma2 from the first 8 bytes of the fee slot
    sigma2 = int(500e14)
    # Get sigma1 from the next 8 bytes of the fee slot
    sigma1 = int(6000e14)
    
    # Calculate the upper bound for the first fee
    upperBound1 = (targetBandwidth * sigma1) // DIVISIONER
    # Calculate the upper bound for the second fee
    upperBound2 = (targetBandwidth * sigma2) // DIVISIONER

    if bandwidth >= upperBound1:
        return 0

    maxWidth = upperBound1 - upperBound2

    # If the bandwidth is smaller than upperBound2
    if bandwidth >= upperBound2:
        # Calculate the fee for the first interval
        fee = calcFee(lambda1, maxWidth, upperBound1, bandwidth, 0, roundDown)
    else:
        # Calculate the fee for the first interval
        fee = calcFee(lambda1, maxWidth, upperBound1, upperBound2, 0, roundDown)

        # offset = lambda1 * 2
        lambda1 *= 2

        # Calculate the fee for the second interval
        fee2 = calcFee(lambda2, upperBound2, upperBound2, bandwidth, lambda1, roundDown)

        # Add the two fees together
        fee += fee2
        
    return fee


def calcFee(feeTier, maxWidth, upperBound, bandwidth, offset, roundDown):
    # Calculate the height of the trapezium
    height = upperBound - bandwidth

    # Calculate the width of the trapezium, rounded up
    width = ((height * feeTier + maxWidth - 1) // maxWidth) + offset

    # Calculate the fee for this tier
    if roundDown:
        fee = (width * height) // DIVISIONER
    else:
        fee = (width * height + DIVISIONER - 1) // DIVISIONER
    return fee

def mint(amount):
    print("minting "+str(amount)+" underlying")
    global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance
    
    _totalWeights = totalWeights
    _totalSupply = totalSupply
    _newTotalSupply = _totalSupply + amount

    bandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(True, True, amount, _totalWeights, _newTotalSupply)

    output = 0
    negativeFee = 0
    i = 0
    while i < length:
        updateAmount = bandwidthUpdateAmounts[i]
        if updateAmount > 0:
            output += updateAmount

        _positiveFee, _negativeFee = updateBandwidth(False, True, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)

        if _positiveFee > 0:
            negativeFee += _positiveFee
        else:
            output += _negativeFee
        i += 1

    if negativeFee > output:
        #raise Exception("Underflow()")
        pass

    output -= negativeFee
    
    LPBalance += output
    
    if output > UnderBalance:
        raise Exception("Underflow()")
    UnderBalance -= output
    
    totalSupply += amount
    poolBalance += output
    print("receiving "+str(output)+" lp")
    print()
    
def deposit(amount):
    print("depositing "+str(amount)+" underlying")
    global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance
    
    _totalWeights = totalWeights
    _totalSupply = totalSupply
    _newTotalSupply = _totalSupply + amount

    bandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(False, True, amount, _totalWeights, _newTotalSupply)

    output = 0
    negativeFee = 0
    i = 0
    while i < length:
        updateAmount = bandwidthUpdateAmounts[i]
        if updateAmount > 0:
            output += updateAmount

        _positiveFee, _negativeFee = updateBandwidth(True, True, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)

        if _positiveFee > 0:
            output += _positiveFee
        else:
            negativeFee += _negativeFee

        i += 1

    if negativeFee > output:
        raise Exception("Underflow()")

    output -= negativeFee
    
    LPBalance += output
    
    if amount > UnderBalance:
        raise Exception("Underflow()")
    UnderBalance -= amount
    
    totalSupply += output
    poolBalance += amount
    print("receiving "+str(output)+" lp")
    print()
    
def redeem(amount):
    print("redeeming "+str(amount)+" lp")
    global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance
    
    totalSupply -= amount
    
    if amount > LPBalance:
        raise Exception("Underflow()")        
    LPBalance -= amount
    
    _totalWeights = totalWeights
    _newTotalSupply = totalSupply
    _totalSupply = _newTotalSupply + amount

    bandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(False, False, amount, _totalWeights, _totalSupply)

    output = 0
    negativeFee = 0
    i = 0
    while i < length:
        updateAmount = bandwidthUpdateAmounts[i]
        if updateAmount > 0:
            output += updateAmount

        _positiveFee, _negativeFee = updateBandwidth(False, False, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)
        #if _positiveFee > 0:
            #raise Exception("nooooo()")
        negativeFee += _negativeFee

        i += 1

    if negativeFee > output:
        raise Exception("Underflow()")
    output -= negativeFee
    
    UnderBalance += output
    poolBalance -= output
    print("receiving "+str(output)+" underlying")
    print()
    
def getIdealPoolBalance():
    global length, bandwithArray, weightArray, totalWeights, totalSupply
    assets = 0

    for i in range(length):
        targetBandwidth = totalSupply * weightArray[i] // totalWeights
        assets += calculateRebalancingFee(bandwithArray[i], targetBandwidth, False)
        #print(calculateRebalancingFee(bandwithArray[i], targetBandwidth, False))
        assets += bandwithArray[i]
        #print(bandwithArray[i])
    
    return assets

def getFeeStatus():
    global length, bandwithArray, weightArray, totalWeights, totalSupply
    assets = 0

    for i in range(length):
        targetBandwidth = totalSupply * weightArray[i] // totalWeights
        assets += calculateRebalancingFee(bandwithArray[i], targetBandwidth, False)
        print(i)
        print(calculateRebalancingFee(bandwithArray[i], targetBandwidth, False))
    
    return assets

'''
cnt = 0
cnttt = 0        
recordinso = []
recordluck = []


for i in range(100000):
    DIVISIONER = int(1e18)
    length = 3
    bandwithArray = [randint(0, int(1e27)) for _ in range(length)]
    weightArray = [1] + [randint(1, 100) for _ in range(length - 1)]
    #weightArray = [1, 1000]
    totalWeights = sum(weightArray)
    totalSupply = int(1e27)
    poolBalance = getIdealPoolBalance()
    
    UnderBalance = 0
    beforeFee = getFeeStatus()
    #amount = randint(0, int(1e25))
    amount = 10000000000
    LPBalance = amount
    redeem(amount)
    afterFee = getFeeStatus()
    if poolBalance < getIdealPoolBalance():
        print(str(poolBalance)+" insolvency! "+str(getIdealPoolBalance()))
        cnt += 1
        recordinso.append(getIdealPoolBalance() - poolBalance)
        raise Exception("Strange()")
        
    if UnderBalance + afterFee > amount + beforeFee :
        print("lucky!")
        recordluck.append(UnderBalance + afterFee - amount - beforeFee)
        cnttt += 1
    print(i)
print(cnt)
print(cnttt)


'''
cnt = 0
cnttt = 0
recordinso = []
recordluck = []
recordcomp = []

for i in range(1):

    DIVISIONER = int(1e18)
    length = 3
    #bandwithArray = [randint(0, int(1e27)) for _ in range(length)]
    bandwithArray = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517]
    #weightArray = [1] + [randint(1, 100) for _ in range(length - 1)]
    weightArray = [1, 59, 47]
    totalWeights = sum(weightArray)
    totalSupply = int(1e27)
    poolBalance = getIdealPoolBalance()
    
    LPBalance = 0
    UnderBalance = int(1e26)
    beforeFee = getFeeStatus()
    #amount = randint(0, int(1e10))
    amount = 10000000

    deposit(amount)
    afterFee = getFeeStatus()

    if poolBalance < getIdealPoolBalance():
        print(str(poolBalance)+" insolvency! "+str(getIdealPoolBalance()))
        cnt += 1
        recordinso.append(getIdealPoolBalance() - poolBalance)
        recordcomp.append(LPBalance + afterFee - amount - beforeFee)
        #raise Exception("good")
        
    if LPBalance + afterFee > amount + beforeFee:
        print("lucky!")
        cnttt += 1
        recordluck.append(LPBalance + afterFee - amount - beforeFee)
        #break
    print(i)
print(cnt)
print(cnttt)
```
## Recommended Mitigation Steps
Deprecate the "deposit" method. It is hard to find a correct way to handle this.


## Assessed type

Context