## Tags

- bug
- 2 (Med Risk)
- downgraded by judge
- primary issue
- selected for report
- M-10

# [Functions cancelMinipool() doesn't reset the value of the RewardsStartTime for user when user's minipoolcount is zero](https://github.com/code-423n4/2022-12-gogopool-findings/issues/555) 

# Lines of code

https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L271-L283
https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L642-L665


# Vulnerability details

## Impact
the value of `RewardsStartTime`  shows when node runner started the minipool and validation rewards are generated by node runner. it is used to see if node runners are eligible for ggp rewards or not and node runners should run their node for minimum amount of time during the rewarding cycle to be eligible for rewards. but right now node runner can create a mimipool and cancel it (after waiting time) and even so the minipool generated no rewards and cancelled the value of `RewardsStartTime` won't get reset for node runner and in the end of the cycle node runner would be eligible for rewards (node runner can create another minipool near the end of cycle). so this issue would cause wrong reward distribution between node runners and code doesn't correctly track `RewardsStartTime` for node runners and malicious node runners can use this issue and receive rewards without running validation nodes for the minimum amount of required time.

## Proof of Concept
This is `cancelMinipool()` and `_cancelMinipoolAndReturnFunds()` code:
```
	function cancelMinipool(address nodeID) external nonReentrant {
		Staking staking = Staking(getContractAddress("Staking"));
		ProtocolDAO dao = ProtocolDAO(getContractAddress("ProtocolDAO"));
		int256 index = requireValidMinipool(nodeID);
		onlyOwner(index);
		// make sure they meet the wait period requirement
		if (block.timestamp - staking.getRewardsStartTime(msg.sender) < dao.getMinipoolCancelMoratoriumSeconds()) {
			revert CancellationTooEarly();
		}
		_cancelMinipoolAndReturnFunds(nodeID, index);
	}

	function _cancelMinipoolAndReturnFunds(address nodeID, int256 index) private {
		requireValidStateTransition(index, MinipoolStatus.Canceled);
		setUint(keccak256(abi.encodePacked("minipool.item", index, ".status")), uint256(MinipoolStatus.Canceled));

		address owner = getAddress(keccak256(abi.encodePacked("minipool.item", index, ".owner")));
		uint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked("minipool.item", index, ".avaxNodeOpAmt")));
		uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked("minipool.item", index, ".avaxLiquidStakerAmt")));

		Staking staking = Staking(getContractAddress("Staking"));
		staking.decreaseAVAXStake(owner, avaxNodeOpAmt);
		staking.decreaseAVAXAssigned(owner, avaxLiquidStakerAmt);

		staking.decreaseMinipoolCount(owner);

		emit MinipoolStatusChanged(nodeID, MinipoolStatus.Canceled);

		Vault vault = Vault(getContractAddress("Vault"));
		vault.withdrawAVAX(avaxNodeOpAmt);
		owner.safeTransferETH(avaxNodeOpAmt);
	}
```
As you can see there is no check that user's minipool count is zero and if it is to reset the value of `RewardsStartTime` for user so if a user creates a minipool in the start of the cycle and then cancel it after 5 days and wait for end of the cycle and start another minipool and increase his staking AVAX he would be eligible for ggp rewards (`ClaimNodeOp.isEligible()` would return `true` for that user even so the user didn't run node for the required amount of time in the cycle). these are the steps to exploit this:
1. node runner would create a minipool near start time of the ggp rewarding cycle and the value of `RewardsStartTime` would set for node runner.
2. after 5 days that node runner's minipool has not been launched by multisig (for any reason) node runner would call `cancelMinipool()` and code would cancel his minipool but won't reset `RewardsStartTime` for node runner.
3. after 20 days and near end of the gpp reward cycle node runner would create another minipool and start running node.
4. in the end even so node runner only start running node and earning reward near end of the reward cycle but code would count node runner as eligible for rewards because `RewardsStartTime` for node runner shows wrong value.

This bug would cause rewards to be distributed wrongly between node runners and malicious node runners can bypass required time for running nodes during reward cycle to be eligible for rewards.

## Tools Used
VIM

## Recommended Mitigation Steps
set the value of `RewardsStartTime` based on successfully finished minipools or when minipool is launched and user can't cancel minipool.